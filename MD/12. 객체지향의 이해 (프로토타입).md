# 프로토타입은 유전자임

우리가 저번시간 배웠던 내용은 멋진 객체지향 용어로 **상속(inheritance)**이라고 합니다.

기계라는 constructor가 가진 name, age 속성들을 그대로 물려받아서 오브젝트를 하나 뽑아주는것을 상속이라 합니다.

(그래서 상속해주는 것은 **부모**, 상속받는 오브젝트들은 **자식**이라고 많이 비유해서 불러요)

## constructor말고 프로토타입도 쓸수있음

근데 자바스크립트엔 constructor 말고도 상속기능을 구현할 수 있는 장치가 하나 더 있습니다.

prototype이라는 것인데 알아보도록 합시다.

**기계를 만드시면 prototype이라는 항목이 기계 안에 몰래 생성됩니다.**

▲ 위의 사실이 진짜인지 확인해보고 싶으면 출력해보시면 됩니다.

여러분이 만든 기계는 전부 prototype이라는 항목을 내부에 몰래 생성합니다.

```jsx
function 기계() {
  this.name = 'Kim';
  this.age = 15;
}
var 학생1 = new 기계();
var 학생2 = new 기계();

console.log(기계.prototype);
```

그럼 뭔진 모르겠는데 뭔가 출력되긴하죠?

갑자기 알게된 prototype이라는 비밀 공간은 왜 존재하고 어디에 쓰는 거냐면

이것이 바로 **부모의 유전자역할**을 해주는 일종의 비밀 공간이라고 보시면 됩니다.

# 프로토타입은 유전자다.

prototype은 자식들이 물려받을 수 있는 **유전자**라고 생각하시면 됩니다.

기계.prototype은 기계의 유전자입니다.

**기계.prototype** 에 뭔가 변수나 함수가 들어가있다면

기계로부터 생성되는 새로운 오브젝트들(자식들)은 전부 그걸 그대로 물려받아 쓸 수 있습니다.

## 예를들면,

예를 들면 이렇게 됩니다.

예제 코드에 prototype 한줄을 추가해보겠습니다.

```jsx
function 기계() {
  this.name = 'Kim';
  this.age = 15;
}

기계.prototype.gender = '남';
var 학생1 = new 기계();
var 학생2 = new 기계();

console.log(학생1.gender); //'남'이 출력됩니다
```

제가 기계의 prototype이라는 곳에 { gender : '남' } 이라는 **key/value 한쌍**을 저장했습니다.

**(prototype은 저렇게 오브젝트 자료형 다루듯이 하면 됩니다)**

기계의 prototype, 즉 유전자에 gender : '남'이라는 데이터를 추가한 것입니다.

이제 학생1, 학생2 같은 **기계로부터 생성되는 모든 자식들은 gender라는 속성을 사용할 수 있습니다.**

진짠지는 출력해보시면 되죠?

그래서 결론은 prototype 이라는 비밀 공간을 이용하시면 똑같이 상속기능을 만들 수 있습니다.

## 프로토타입은 {key : value} object로 다룰 수 있다 했으니 , 당연히 값 여러개 가능하며 함수까지 넣어도 괜찮다.

- prototype에는 값을 여러개 부여할 수도 있고 심지어 함수도 집어넣으실 수 있습니다. object 자료처럼 다뤄주시면 됩니다.
- prototype에 추가된 데이터들은 자식들이 직접 가지는게 아니라 부모만 가지고 있습니다.

# prototype 작동원리 #1. 자바스크립트의 기본 동작 ( 부모님 모셔와)

**하지만 작동원리가 궁금하지 않으십니까**

도대체 왜 prototype에 추가한 데이터는 자식들이 자유롭게 가져다 쓸 수 있는지 안궁금하세요?

### 일단 자바스크립트의 기본 동작이 존재함

자바스크립트는 **오브젝트에서 데이터를 뽑을 때** 확인하는 순서가 있습니다.

예를 들면

```jsx
function 기계() {
  this.name = 'Kim';
  this.age = 15;
}
기계.prototype.gender = '남';
var 학생1 = new 기계();

console.log(학생1.gender);
```

▲ 학생1.gender라고 사용하면 '남'이 출력되죠? 그 이유는..

**자바스크립트는 오브젝트에서 값을 출력할 때** 이런 순서로 물어봅니다. (프로세스)

**(1) 학생1에 직접 gender라는 값이 있는가? (없는데요)**

**(2) 그럼 부모 유전자에 gender라는 값이 있는가? (없어요)**

**(3) 그럼 부모의 부모 유전자에 gender라는 값이 있는가? (있었는데?)**

(4) 그럼 부모의 부모의 부모의 유전자에 .. 그게 있는가?

자바스크립트는 이런 알고리즘으로 작동합니다.

### 더 쉬운 버전임

1. 내가 직접 가지고 있는지 검사

2. 내가 가지고 있지 않으면 부모 유전자들을 차례로 검사

## 그래서 현재 없는 속성도 우리가 쓸 수 있는거임

그래서 학생1이라는 오브젝트가 gender라는 값을 가지고 있지 않지만

부모의 유전자(기계.prototype) 에 있는 gender라는 걸 출력할 수 있는 이유입니다.

# prototype 작동원리 #2. 내장함수의 자연스러운 활용

자바스크립트 array, object 들에는 붙일 수 있는 내장함수들이 많습니다.

sort, push, toString, map, forEach 등 이런 것들을 array에 붙여서 사용가능한데 혹시 그 이유가 궁금하지 않으셨습니까.

## 없는걸 어케씀

결론부터 말하자면 매우 쉽습니다.

```jsx
var arr = [1, 2, 3];
console.log(arr.toString()); //가능
```

내가 만든 array에 arr.toString() 이렇게 붙일 수 있는 이유는

내가 만든 array의 부모 유전자가 toString()을 가지고 있기 때문입니다. (혹은 부모의 부모)

## 내가 부모 기계로 생성한적이 없는데요

- **내가 만든 array는 부모 기계로 부터 뽑은게 아닌데 뭔소리하는 거냐고요?**

```jsx
var arr = [1, 2, 3];
var arr = new Array(1, 2, 3);
```

**▲ 위 코드 두줄은 같은 완전 똑같은 의미입니다.**

## 즉 우리(인간)이 배열 선언하는 방식과 컴퓨터가 선언하는 방식은 다름

위는 인간이 array 만드는 방식, 밑은 컴퓨터가 array 만드는 방식입니다.

사람은 귀찮아서 [] 그냥 대괄호쳐서 만드는데 **내부적으로는 저렇게 new 키워드를 항상 이용해서 array/object를 만들어줍니다.**

## Array() 함수 (기계)로 만든거잖슴 (컴터가 이렇게 만듬)

그럼 **new Array()** 이게 뭔뜻이죠?

Array라는 기계로부터 자식을 하나 새로 뽑아주세요 라는 뜻 아닌가요?

맞습니다.

그래서 Array로부터 생성된 자식들은 Array의 유전자에 부여되어있는 함수, 데이터들을 자유롭게 사용하실 수 있습니다.

### 의심할수 있으니 콘솔에 찍어보셈 Array.prototype (유전자 검사)

Array라는 기계의 유전자가 진짜 있는지 확인은 콘솔창에 출력해보시면 됩니다.

```coffeescript
console.log(Array.prototype);
```

이렇게 하면 뭐나옵니까. 여러분이 평소에 쓰던 sort, map, push, forEach 이런 것들이 등장합니다.

그래서 Array의 자식들은 전부 이런 함수들을 쉽게 가져다 쓸 수 있었던 것입니다.

# Array() 뿐만 아니라 Object()도 대가족

Object 자료형도  똑같이 new Object() 이런 식으로 만들어주기 때문에 부모의 prototype에 있던 함수들을 자유롭게 사용가능합니다.

이것이 내장함수들의 [비밀이었습니다.](http://비밀이었습니다.pe)

# Prototype vs Constructor

**Q. 그럼 prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이가 뭐죠?**

**A. 자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고**

**부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 되겠습니다.**

### 일반적인 컨벤션은 → 상속가능한 함수는 프로토타입으로 많이 만듬

보통은 그래서 상속할 수 있는 함수 같은 것들은 prototype으로 많이 만들어놓습니다.

# 프로토타입의 은밀한 특성 (유전자 주입과 만물의 어머니 조회)

**1. prototype은 constructor 함수에만 몰래 생성됩니다.**

여러분이 일반 object, array 이런거 만들어도 거기엔 prototype이 없습니다.

그럼 일반 object 같은걸 상속하고 싶으면 어떻게 하냐고요?

**constructor 함수를 만들어도 좋고, ES6꺼 쓰면 좋겠네요 ( 다음 MD파일에 소개합니다)**

**2. 내 부모님 유전자를 찾고 싶다면 **proto**를 출력해보시면 됩니다.**

부모로부터 생성된 자식 object들은 **proto**라는 **속성**이 있습니다.

이걸 출력해보시면 **부모의 prototype**이 출력됩니다.

그래서 ****proto**는 부모의 prototype**과 같은 의미입니다.

진짜 그런지 한번 출력해봅시다.

```jsx
function 기계() {
  this.name = 'Kim';
  this.age = 15;
}
var 학생1 = new 기계();
console.log(학생1.__proto__);
console.log(기계.prototype);
```

**학생1.**proto** (자식.부모의유전자)**

**기계.prototype (부모.나의유전자)**

각각 출력해보시면 똑같은게 나오죠?

아무튼 그래서 **"**proto**는 부모 prototype을 의미한다"** 라고 알아두시면 끝!

그냥 **proto**는 내 부모 유전자가 뭔지 유전자 검사하고 싶을 때 쓸 수 있는 그런 값이라고 생각하시면 되겠습니다.

### 상속 강제화 (유전자 주입) 위에서 **proto ** 는 부모의 유전자를 의미한다했으니..

**3. **proto**를 직접 등록하면 object끼리 상속기능을 구현가능합니다. (유전자 공학)**

**proto**는 부모의 prototype을 의미한다 라고 했습니다.

그럼 어떤 object에다가 **proto**를 강제로 하나 설정해버리면 어떻게 될까요?

**오 이런 부모님이 생겨버립니다.**

일종의 유전자 공학인데 한번 실험해봅시다.

```jsx
var 부모 = { name: 'Kim' };
var 자식 = {};

자식.__proto__ = 부모;
console.log(자식.name);
```

지금 부모와 자식 object를 하나씩 만들었습니다.

그리고 셋째줄에서 자식의 **proto**에 부모를 집어넣었습니다.

그럼 자식의 부모 유전자는 { name : 'Kim' } 이라는 오브젝트가 되는 것입니다.

그렇게 되면 자식은 이제 자식.name 속성을 자유롭게 사용할 수 있습니다.

**상속기능 구현을 이렇게도 할 수 있군요.**

## 궁금하면 콘솔 ㄱ

**4. 실은 콘솔창에 prototype 정보들이 항상 출력됩니다.**

콘솔창에서 학생1 한번 출력해보십시오.

```jsx
function 기계() {
  this.name = 'Kim';
  this.age = 15;
}
기계.prototype.gender = '남';

var 학생1 = new 기계();
```

그럼 콘솔창에 name도 나오고 age도 나올 텐데

**이상한 **proto** 속성 발견 가능**

!https://codingapple-cdn.b-cdn.net/wp-content/uploads/2020/03/%EC%BA%A1%EC%B2%98-2.png

▲ ****proto**가 뭐랬습니까. 부모의 유전자라고 했죠?**

그래서 이걸 항상 까보실 수 있습니다.

→ 아마 기계.prototype이랑 똑같은 내용이 출력되겠죠. (부모의 유전자니까)

그리고 기계.prototype의 **proto**도 조회가능합니다. (기계.prototype의 부모 유전자요)

이렇게 쭉 내 부모의 부모까지 탐색할 수도 있습니다.

### 지속적인 부모님 추적의 결론은 만물의 어머님은 OBJECT이다.

탐색해보시면 모든 object 자료형의 조상은 Object() 라는 기계이며 (일명 Object.prototype)

모든 array 자료형의 조상도 Object()입니다. (중간에 Array()라는 부모도 있고요)

모든 함수 자료형의 조상도 Object() 입니다.

**(그래서 자바스크립트는 모든게 다 Object라고 말하는 것입니다.)**
